function tokenizeTerms(searchTerms)
		{
			let searchTokens = [];
			let key = 0;
			let inParens = false;
			let inQuotes = false;
			for (let i = 0; i < searchTerms.length; i++)
			{
				if (searchTerms.charAt(i) == '(')
				{
					inParens = true;
				}
				if (searchTerms.charAt(i) == ')')
				{
					inParens = false;
				}
				if (!inParens && !inQuotes && (searchTerms.charAt(i) == '"' || searchTerms.charAt(i) == '“' || searchTerms.charAt(i) == '/'))
				{
					inQuotes = true;
				}
				else if (!inParens && inQuotes && (searchTerms.charAt(i) == '"' || searchTerms.charAt(i) == '”' || searchTerms.charAt(i) == '/'))
				{
					inQuotes = false;
				}
				if (searchTerms.charAt(i) == ' ' && !inParens && !inQuotes)
				{
					searchTokens.push(searchTerms.substring(key, i));
					key = i + 1;
				}
				if (i == searchTerms.length - 1)
				{
					searchTokens.push(searchTerms.substring(key));
				}
			}

			return searchTokens;
		}

		function searchAllTokens(card, tokens)
		{
			if (tokens.length < 1)
			{
				return true;
			}
			for (let i = 0; i < tokens.length; i++)
			{
				if (tokens[i].charAt(0) == '*')
				{
					return searchAllTokens(card, tokens.slice(0, i)) && searchAllTokens(card, tokens.slice(i + 1));
				}
				if (tokens[i] == "or")
				{
					return searchAllTokens(card, tokens.slice(0, i)) || searchAllTokens(card, tokens.slice(i + 1));
				}
			}

			for (let token of tokens)
			{
				if (token.charAt(0) == '-')
				{
					return !searchToken(card, token.substring(1)) && (tokens.length == 1 ? true : searchAllTokens(card, tokens.slice(1)));
				}
				if (token.charAt(0) == '(')
				{
					return searchAllTokens(card, tokenizeTerms(token.substring(1, token.length - 1))) && (tokens.length == 1 ? true : searchAllTokens(card, tokens.slice(1)));
				}
				else
				{
					return searchToken(card, token) && (tokens.length == 1 ? true : searchAllTokens(card, tokens.slice(1)));
				}
			}
		}

		function searchToken(card, token)
		{
			let card_stats = [];

			for (let i = 0; i < card.length; i++)
			{
				card_stats.push(card[i].toLowerCase());
			}

			let card_name = card_stats[0];
			let card_color = card_stats[1] != "" ? card_stats[1] : "c";
			let card_rarity = card_stats[2];
			let card_type = card_stats[3];
			// 4: collector number
			let card_ci = card_stats[5];
			let card_cost = card_stats[6];
			let card_mv = (isDecimal(card_cost.charAt(0)) ? parseInt(card_cost) + card_cost.replaceAll('x','').length - 1 : card_cost.replaceAll('x','').length) - ((card_cost.split('/').length - 1) * 2);
			let card_oracle_text = card_stats[7] != "" ? card_stats[7].replaceAll("NEWLINE", '\n') : card_stats[9].replaceAll("NEWLINE", '\n');
			let card_power = card_stats[8].substring(0,card_stats[8].indexOf('/'));
			let card_toughness = card_stats[8].substring(card_stats[8].indexOf('/')+1);
			let card_shape = card_stats[10];
			let card_set = card_stats[11];
			let card_loyalty = card_stats[12];
			let card_notes = card_stats[card_stats.length - 1].replaceAll("NEWLINE", '\n');

			let color_map = new Map([
				["azorius", "wu"],
				["dimir", "ub"],
				["rakdos", "br"],
				["gruul", "rg"],
				["selesnya", "gw"],
				["orzhov", "wb"],
				["golgari", "bg"],
				["simic", "gu"],
				["izzet", "ur"],
				["boros", "rw"],
				["esper", "wub"],
				["grixis", "ubr"],
				["jund", "brg"],
				["naya", "rgw"],
				["bant", "gwu"],
				["abzan", "wbg"],
				["sultai", "bgu"],
				["temur", "gur"],
				["jeskai", "urw"],
				["mardu", "rwb"],
			]);

			// two cards in one
			if (card_shape.includes("adventure") || card_shape.includes("double") || card_shape.includes("spli"))
			{
				card_name = card_name + "	" + card_stats[13];
				card_type = card_type + "	" + card_stats[15];
				card_oracle_text = card_oracle_text + "	" + (card_stats[18] != "" ? card_stats[18].replaceAll("NEWLINE", '\n') : card_stats[20].replaceAll("NEWLINE", '\n'));
			}

			token = token.replaceAll("~", card_name).replaceAll("cardname", card_name).replaceAll('"','').replaceAll('/','').replaceAll('“','').replaceAll('”','');

			const modifierRegex = /[!:<>=]+/g;
			const match = token.match(modifierRegex);

			if (match)
			{
				const modifier = match[0];
				const term = token.substring(0, token.indexOf(modifier));
				let check = token.substring(token.indexOf(modifier) + modifier.length);

				if (color_map.has(check))
				{
					check = color_map.get(check);
				}

				// availableTokens = ["mv", "c", "ci", "t", "o", "pow", "tou", "r", "is"]

				/* template
				if (term == "mv")
				{
					if (modifier == "!" || modifier == "=")
					{

					}
					else if (modifier == ":")
					{

					}
					else if (modifier == "<")
					{

					}
					else if (modifier == ">")
					{

					}
				} */
				if (term == "mv")
				{
					if (modifier == "!" || modifier == "=")
					{
						return (card_mv == check);
					}
					else if (modifier == ":")
					{
						return (card_mv == check);
					}
					else if (modifier == "<")
					{
						return (card_mv < check);
					}
					else if (modifier == ">")
					{
						return (card_mv > check);
					}
					else if (modifier == "<=")
					{
						return (card_mv <= check);
					}
					else if (modifier == ">=")
					{
						return (card_mv >= check);
					}
				}
				if (term == "c" || term == "color")
				{
					if (modifier == "!" || modifier == "=")
					{
						if (!isNaN(check))
						{
							return card_color.length == parseInt(check);
						}
						return (card_color.split("").sort().join("") == check.split("").sort().join(""));
					}
					else if (modifier == ":")
					{
						if (!isNaN(check))
						{
							return card_color.length == parseInt(check);
						}
						return hasAllChars(card_color, check);
					}
					else if (modifier == "<")
					{
						if (!isNaN(check))
						{
							return card_color.length < parseInt(check);
						}
						return card_color == "c" || (check.length > card_color.length && hasAllChars(check, card_color));
					}
					else if (modifier == ">")
					{
						if (!isNaN(check))
						{
							return card_color.length > parseInt(check);
						}
						return card_color.length > check.length && hasAllChars(card_color, check);
					}
					else if (modifier == "<=")
					{
						if (!isNaN(check))
						{
							return card_color.length <= parseInt(check);
						}
						return card_color == "c" || hasAllChars(check, card_color);
					}
					else if (modifier == ">=")
					{
						if (!isNaN(check))
						{
							return card_color.length >= parseInt(check);
						}
						return hasAllChars(card_color, check);
					}
				}
				if (term == "ci" || term == "id")
				{
					if (modifier == "!" || modifier == "=")
					{
						// why is this the best way to do this?
						if (!isNaN(check))
						{
							return card_ci.length == parseInt(check);
						}
						return (card_ci.split("").sort().join("") == check.split("").sort().join(""));
					}
					else if (modifier == ":")
					{
						if (!isNaN(check))
						{
							return card_ci.length == parseInt(check);
						}
						return hasAllChars(card_ci, check);
					}
					else if (modifier == "<")
					{
						if (!isNaN(check))
						{
							return card_ci.length < parseInt(check);
						}
						return card_ci == "c" || (check.length > card_ci.length && hasAllChars(check, card_ci));
					}
					else if (modifier == ">")
					{
						if (!isNaN(check))
						{
							return card_ci.length > parseInt(check);
						}
						return card_ci.length > check.length && hasAllChars(card_ci, check);
					}
					else if (modifier == "<=")
					{
						if (!isNaN(check))
						{
							return card_ci.length <= parseInt(check);
						}
						return card_ci == "c" || hasAllChars(check, card_ci);
					}
					else if (modifier == ">=")
					{
						if (!isNaN(check))
						{
							return card_ci.length >= parseInt(check);
						}
						return hasAllChars(card_ci, check);
					}
				}
				if (term == "t" || term == "type")
				{
					if (modifier == ":")
					{
						return card_type.includes(check);
					}
					/* unsupported flows
					if (modifier == "!" || modifier == "=")
					{

					}
					else if (modifier == "<")
					{

					}
					else if (modifier == ">")
					{

					} */
				}
				if (term == "o")
				{
					if (modifier == ":")
					{
						regex = new RegExp(check);
						return regex.test(card_oracle_text);
					}
					/* unsupported flows
					if (modifier == "!" || modifier == "=")
					{

					}
					else if (modifier == "<")
					{

					}
					else if (modifier == ">")
					{

					} */
				}
				if (term == "pow")
				{
					if (modifier == "!" || modifier == "=")
					{
						return (card_power == check);
					}
					else if (modifier == ":")
					{
						return (card_power == check);
					}
					else if (modifier == "<")
					{
						return (card_power < check);
					}
					else if (modifier == ">")
					{
						return (card_power > check);
					}
					else if (modifier == "<=")
					{
						return (card_power <= check);
					}
					else if (modifier == ">=")
					{
						return (card_power >= check);
					}
				}
				if (term == "tou")
				{
					if (modifier == "!" || modifier == "=")
					{
						return (card_toughness == check);
					}
					else if (modifier == ":")
					{
						return (card_toughness == check);
					}
					else if (modifier == "<")
					{
						return (card_toughness < check);
					}
					else if (modifier == ">")
					{
						return (card_toughness > check);
					}
					else if (modifier == "<=")
					{
						return (card_toughness <= check);
					}
					else if (modifier == ">=")
					{
						return (card_toughness >= check);
					}
				}
				if (term == "r" || term == "rarity")
				{
					rarities = [ "common", "uncommon", "rare", "mythic" ];
					for (const rarity of rarities)
					{
						if (rarity.startsWith(check))
						{
							check = rarity;
						}
					}
					if (modifier == ":" || modifier == "!" || modifier == "=")
					{
						return (card_rarity == check);
					}
					else if (modifier == "<")
					{
						return rarities.includes(card_rarity) && rarities.indexOf(card_rarity) < rarities.indexOf(check);
					}
					else if (modifier == ">")
					{
						return rarities.includes(card_rarity) && rarities.indexOf(card_rarity) > rarities.indexOf(check);
					}
					else if (modifier == "<=")
					{
						return rarities.includes(card_rarity) && rarities.indexOf(card_rarity) <= rarities.indexOf(check);
					}
					else if (modifier == ">=")
					{
						return rarities.includes(card_rarity) && rarities.indexOf(card_rarity) >= rarities.indexOf(check);
					}
				}
				if (term == "e" || term == "set")
				{
					if (modifier == ":" || modifier == "!" || modifier == "=")
					{
						return (card_set == check);
					}
					/* unsupported flows
					else if (modifier == "<")
					{

					}
					else if (modifier == ">")
					{

					} */
				}
				if (term == "keyword" || term=="kw" || term == "has")
				{
					if (modifier == ":" || modifier == "!" || modifier == "=")
					{
						regex_kw1 = new RegExp(`(^|newline|, )${check}[^.]*($|newline|\\()`, "g");
						regex_kw2 = new RegExp(`(^|newline)${check} `, "g");
						return regex_kw1.test(card_oracle_text) || regex_kw2.test(card_oracle_text);
					}
					/* unsupported flows
					else if (modifier == "<")
					{

					}
					else if (modifier == ">")
					{

					} */
				}
				if (term == "is")
				{
					if (modifier == ":" || modifier == "!" || modifier == "=")
					{
						// all of these are implemented individually
						if (check == "permanent")
						{
							return !card_type.includes("instant") && !card_type.includes("sorcery");
						}
						if (check == "spell")
						{
							return !card_type.includes("land");
						}
						if (check == "commander")
						{
							return (card_type.includes("legendary") && card_type.includes("creature")) || card_oracle_text.includes("can be your commander");
						}
						if (check == "hybrid")
						{
							return (card_cost.includes("/"));
						}
					}
					/* unsupported flows
					else if (modifier == "<")
					{

					}
					else if (modifier == ">")
					{

					} */
				}
				if (term == "tag")
				{
					if (modifier == ":" || modifier == "=" || modifier == "!")
					{
						return card_notes.includes("!tag " + check);
					}
					/* unsupported flows
					else if (modifier == "<")
					{

					}
					else if (modifier == ">")
					{

					} */
				}
			}

			return card_name.includes(token);
		}